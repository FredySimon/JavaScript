<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Funciones</title>
</head>

<body>
    <h1>Funciones</h1>
    <hr>

    <!--Las funciones de JavaScript se definen con la functionpalabra clave. Puede usar una declaración de función o una expresión de función. -->

    <!--Una función de JavaScript es un bloque de código diseñado para realizar una tarea en particular. función puede tener 0 parametros, parametros: no lleva tipo de dato, Argumento: valores que pasamos a (y que recibe) una función. Una función de JavaScript se ejecuta cuando "algo" lo invoca (lo llama). Puede usar el mismo código muchas veces con diferentes argumentos, para producir resultados diferentes. Acceder a una función sin () devolverá la definición de la función en lugar del resultado de la función. Las funciones se pueden usar de la misma manera que las variables, en todos los tipos de fórmulas, tareas y cálculos. Los puntos y comas se usan para separar las sentencias ejecutables de JavaScript. Como una declaración de función no es una declaración ejecutable, no es común terminarla con un punto y coma. El izado se aplica a las declaraciones de variables y a las declaraciones de funciones. Las funciones definidas usando una expresión no se izan.-->
    <p id="demo"></p>
    <script>
        function saludo() {
            return "Hola"
        }
        function producto(a, b) {
            return a * b;
        }
        var multiplicacion = function (a, b) { return a * b; };
        var division = new Function("a", "b", "return a / b;");
        function suma(a, b) {
            if (b === undefined) {
                b = 0;
            }
            return a + b;
        }
        var resultado = suma(4)
        var x = myFunction(4, 3);
        function myFunction(p1, p2) {
            return p1 * p2;
        }
        function convertirCelsius(f) {
            return (5 / 9) * (f - 32);
        }
        document.getElementById("demo").innerHTML = saludo() + "<br>" + producto(3, 4) + "<br>" + ("Funciones anónimas:" + multiplicacion(3, 6)) + "<br>" + ("Constructor función: " + division(10, 2)) + "<br>" + resultado + "<br>" + x + "<br>" + convertirCelsius(77);
    </script>
    <hr>

    <!--parametros por exceso-->
    <p id="demo1"></p>
    <script>
        function valores() {
            var texto = '';
            texto += "El numero de argumentos es " + arguments.length + "<br>";
            for (var i = 0; i < arguments.length; i++) {
                texto += "Argumeto " + i + " = " + arguments[i] + "<br>";
            }
            document.getElementById("demo1").innerHTML = texto;
        }
        valores(4, 6, 8, 2, 7, 5, 8, 5, 0, 3);
    </script>
    <hr>

    <script>
        //anonima autoinvocada
        (function () {
            alert("Hola")
        }())
    </script>

    <!--Las variables declaradas dentro de una función de JavaScript se vuelven LOCALES a la función.  Solo se puede acceder a las variables locales desde la función.-->
    <p id="demo2"></p>
    <p id="demo3"></p>
    <script>
        variables();
        function variables() {
            var carName = "Volvo";
            document.getElementById("demo2").innerHTML = typeof carName + " " + carName
        }
        document.getElementById("demo3").innerHTML = typeof carName;
    </script>
    <hr>

    <!--variables como funciones. En JavaScript puede definir funciones como métodos de objeto.-->
    <script>
        var persona = { nombre: "asdsd", apellido: "sadsd", id: 1, nombreCompleto: function () { return this.nombre + " " + this.apellido + ".-"; } };
    </script>

    <!--El toString()método devuelve la función como una cadena. Una función definida como la propiedad de un objeto, se llama un método para el objeto. Una función diseñada para crear nuevos objetos, se denomina constructor de objetos.-->
    <p id="demo8"></p>
    <script>
     function funciontoString(a, b){
         return a * b;
     }
     document.getElementById("demo8").innerHTML=funciontoString.toString();
    </script>
    <hr>

    <!--Las funciones de JavaScript tienen un objeto incorporado llamado objeto de argumentos. El objeto de argumento contiene una matriz de los argumentos utilizados cuando se llamó a la función (invocada).-->
    <p id="demo9"></p>
    <script>
        function buscarMayor(){
            var i;
            var max = -Infinity;
            for (i=0; i<arguments.length; i++){
                if(arguments[i] > max){
                    max = arguments[i];
                }
            }
            return max;
        } 
        document.getElementById("demo9").innerHTML=buscarMayor(4, 5, 6, 7);
    </script>
    <hr>

    <!--Sumar todos los parametros que recibe una función.-->
    <p id="demo10"></p>
    <script>
    function sumarTodos(){
        var i;
        var suma = 0;
        for (i=0; i<arguments.length; i++){
            suma += arguments[i];
        }
        return suma;
    }
    document.getElementById("demo10").innerHTML=sumarTodos(1, 123, 500, 115, 44, 88);
    </script>
    <hr>

    <!--En un navegador, el objeto de la página es la ventana del navegador. La función siguiente se convierte automáticamente en una función de ventana.-->
    <p id="demo11"></p>
    <script>
    function restar(a, b){
        return a - b;
    }
    document.getElementById("demo11").innerHTML=window.restar(10, 2);
    </script>
    <hr>

    <!--Si una invocación de función está precedida por la newpalabra clave, es una invocación de constructor.-->
    <p id="demo12"></p>
    <script>
    function funcionCOnstructor(a, b){
        this.nombre = a;
        this.apellido = b;
    }
    var z = new funcionCOnstructor("John", "Doe");
    document.getElementById("demo12").innerHTML=z.nombre;
    </script>
    <hr>

    <!--El call()método es un método de JavaScript predefinido. Se puede utilizar para invocar (llamar) un método con un objeto propietario como argumento (parámetro). Con el call()método, puede escribir un método que pueda usarse en diferentes objetos. Con call(), un objeto puede usar un método que pertenece a otro objeto. El call()método puede aceptar argumentos.-->
    <p id="demo13"></p>
    <script>
    var persona1 = {
        completo: function(ciudad, pais){
            return this.nombre + " " + this.apellido + ", " + ciudad + ", " + pais;
        }
    }
    var persona2 = {
        nombre: "John",
        apellido: "Doe"
    }
    var y = persona1.completo.call(persona2, "Guatemla", "Guatemala");
    document.getElementById("demo13").innerHTML=y;
    </script>
    <hr>

    <!--Con el apply()método, puede escribir un método que pueda usarse en diferentes objetos. El método apply () es muy útil si desea usar una matriz en lugar de una lista de argumentos. El apply()método acepta argumentos en una matriz-->
    <p id="demo14"></p>
    <script>
    var carro = {
        registroCarro: function(pais, dueño){
            return this.marca + " " + this.modelo + ", " + pais + " " + dueño;
        }
    }
    var carro1 = {
        marca:"BMW",
        modelo:1995
    }
    var x = carro.registroCarro.apply(carro1, ["Alemania", "Fredy"]);
    document.getElementById("demo14").innerHTML=x;
    </script>
    <hr>

    <!--El call()método toma argumentos por separado. El apply()método toma argumentos como una matriz .-->

    <!--Dado que las matrices de JavaScript no tienen un método max (), puede aplicar el Math.max()método en su lugar.-->
    <p id="demo15"></p>
    <script>
    document.getElementById("demo15").innerHTML=Math.max.apply(null, [1,2,3]) + " o " + Math.max.apply(Math, [1,2,3]) + " o " + Math.max.apply(" ", [1,2,3]) + " o " + Math.max.apply(0, [1,2,3]);
    </script>
    <hr>

    <!--Contador-->
    <button id="demo16" type="button" onclick="document.getElementById('demo16').innerHTML=++j">Click</button>
    <script>
    var j = 0;
    </script>
    <hr>

    <h1>Funciones de flecha</h1>
    <hr>

    <!--Las funciones de flecha se introdujeron en ES6.Las funciones de flecha nos permiten escribir una sintaxis de función más corta-->
    <p id="demo4"></p>
    <script>
        var hola = () => {
            return "Hola mundo";
        }
        document.getElementById("demo4").innerHTML = hola();
    </script>
    <hr>

    <!--¡Se acorta! Si la función tiene solo una instrucción y la instrucción devuelve un valor, puede eliminar los corchetes y la returnpalabra clave. Si tiene parámetros, los pasa dentro de los paréntesis-->
    <p id="demo5"></p>
    <script>
        var saludo = (valor) => "HOLA" + valor;
        document.getElementById("demo5").innerHTML = saludo("UNIVERSO");
    </script>
    <hr>

    <!--De hecho, si solo tiene un parámetro, también puede omitir los paréntesis-->
    <script>
        var despedida = valor => valor + ".";
        console.log(despedida("ADIOS"));
    </script>

    <!--El manejo de this también es diferente en las funciones de flecha en comparación con las funciones regulares. En las funciones regulares, la this palabra clave representaba el objeto que llamaba a la función, que podría ser la ventana, el documento, un botón o lo que sea.-->
    <button id="btn">Click</button>
    <p id="demo6"></p>
    <script>
        var funcion;
        funcion = function(){
            document.getElementById("demo6").innerHTML += this;
        }
        window.addEventListener("load", funcion);
        document.getElementById("btn").addEventListener("click", funcion);
    </script>
    <hr>

    <!--Con una función de flecha this representa el propietario de la función. Con las funciones de flecha, la this palabra clave siempre representa el objeto que definió la función de flecha.-->
    <button id="btn1">Click</button>
    <p id="demo7"></p>
    <script>
    var a = () => {
        document.getElementById("demo7").innerHTML+=this;
    };
    window.addEventListener("load", a);
    document.getElementById("btn1").addEventListener("click", a);
    </script>
    <hr>

    <!---->
</body>

</html>